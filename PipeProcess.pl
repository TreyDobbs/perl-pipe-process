#!/usr/bin/perl
# This program will accept three command-line arguments. The program should verify the 
# number of arguments and the validation of the arguments. If the arguments are valid, 
# the program should create four child processes. After the parent process creates the 
# child processes, it should wait so that the child processes can finish. The child processes 
# should send the sum of its generated numbers to the parent using a pipe. The parent should 
# compute the global mean of all the data (rounded to the nearest hundredth) and send that 
# mean back to each of the four child processes using the pipe. Each child process will
# display a single line (shown at bottom of report) summarizing its statistics. The parent 
# process should generate a report heading (to the screen). 
# Written by Trey Dobbs


use POSIX ":sys_wait_h";
use POSIX qw(mkfifo);

( $per_child, $min, $max ) = @ARGV;

# fatal
if (scalar @ARGV != 3 or not ($per_child =~ m/^\d+$/ and $min =~ m/^\d+$/ and $max =~ m/^\d+$/)) {
    warn "Exactly 3 arguments, all integers, are required: NUM_RANDOM_NUMBERS MIN_RANDOM_NUMBER MAX_RANDOM_NUMBER\n";
    warn "Example,
        $0 200 100 1000\n";
    exit 1;
}

# fatal
if ($min > $max) {
    warn "MIN_RANDOM_NUMBER ($min) must be LESS THAN MAX_RANDOM_NUMBER ($max)!\n";
    exit 1;
}

# not fatal
if ($min == $max) {
    warn "(warning!!) MIN_RANDOM_NUMBER ($min) is equal to MAX_RANDOM_NUMBER ($max)!\n";
}

%CHILDREN = ();

K:
for ( 1 .. 4 ) {
    $pid = fork;

    if ( $pid > 0 ) {

        # PARENT CODE
        $CHILDREN{$pid} = $pid;
        next K;
    }

    # CHILD CODE
    srand $$;

    # generate random numbers, per child
    $sum   = 0;
    @rando = ();
    for $i ( 1 .. $per_child ) {
        $random;
        do {
            $random = int rand $max + 1;
        } while ( $random < $min );

        # store random numbers, track running sum
        push @rando, $random;
        $sum = $sum + $random;
    }

    # compute local statistics (mean, above, below)
    $mean = 0;
    foreach $r (@rando) {
        $mean = $r + $mean;
    }
    $mean = $mean / $per_child;

    $above = 0;
    $below = 0;
    foreach $r (@rando) {
        if ( $r > $mean ) {
            $above = $above + 1;
        }
        else {
            $below = $below + 1;
        }
    }

    # make named piped for child to communicate with parent
    $pipe_name = qq{./pipe_$$};
    mkfifo( $pipe_name, 0700 ) or die $!;

    # write sum to parent via named pipe
    open $WFIFO, q{>}, $pipe_name or die $!;
    print $WFIFO qq{$sum\n};

    # will wait for parent..
    close $WFIFO;

    # now, get global mean from parent
    open $WFIFO, q{<}, $pipe_name or die $!;
    $global_mean = <$WFIFO>;
    $count       = <$WFIFO>;
    chomp $global_mean;
    chomp $count;
    close $WFIFO;

    # output summation line, will happen after parent has output the global header
    printf qq{%d\t%d\t%.2f\t%d\t%d\n}, $count, $$, $mean, $below, $above;

    # clean up named pipe
    unlink $pipe_name;

    # this exit marks the end of the child process
    exit;
}

# EXECUTED BY PARENT ONLY
@children = keys %CHILDREN;
%sums     = ();
foreach $cpid ( sort { $a <=> $b } @children ) {

    # open child pipe for reading
    $pipe_name = qq{./pipe_$cpid};

    # barrier, will proceed when $pipe_name has been created by the child
    while ( not -p $pipe_name ) { }

    # proceed to read sum from child pipe
    open $RFIFO, q{<}, $pipe_name || die $!;
    $sum = <$RFIFO>;
    chomp $sum;
    $sums{$cpid} = $sum;
    close $RFIFO;
}

$global_mean = 0;
foreach $sum ( values %sums ) {
    $global_mean = $sum + $global_mean;
}
$global_mean = sprintf( "%.2f", $global_mean / ( $per_child * 4 ) );

print <<EOF;
Range of numbers: $min through $max 
Numbers generated by each process: $per_child
Global mean (rounded to nearest hundredth): $global_mean 

Analysis compared to the global mean:

Process\tPID\tMean\tBelow\tAbove
EOF

$count = 0;
foreach $cpid ( sort { $a <=> $b } @children ) {

    # open child pipe for reading
    $pipe_name = qq{./pipe_$cpid};
    open $RFIFO, q{>}, $pipe_name || die $!;

    # send global mean to child
    print $RFIFO qq{$global_mean\n};

    # send process index (0-3) to child, as known to parent
    print $RFIFO qq{$count\n};
    close $RFIFO;

    # barrier, will proceed when $pipe_name has been destroyed by child
    while ( -p $pipe_name ) { }

    # increase count, sent to child process
    $count = $count + 1;
}
